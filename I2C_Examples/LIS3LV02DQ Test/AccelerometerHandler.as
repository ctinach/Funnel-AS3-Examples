/*********************************************************************** 12/26/2010. Jeff Hoefs Ported to as3 from ofxAccelerometer by Memo Atken  Copyright (c) 2008, 2009, Memo Akten, www.memo.tv *** The Mega Super Awesome Visuals Company *** * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions are met: * *     * Redistributions of source code must retain the above copyright *       notice, this list of conditions and the following disclaimer. *     * Redistributions in binary form must reproduce the above copyright *       notice, this list of conditions and the following disclaimer in the *       documentation and/or other materials provided with the distribution. *     * Neither the name of MSA Visuals nor the names of its contributors  *       may be used to endorse or promote products derived from this software *       without specific prior written permission. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"  * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS  * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY * OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE  * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED * OF THE POSSIBILITY OF SUCH DAMAGE.  * * ***********************************************************************/ package  {		import flash.geom.Vector3D;	import flash.geom.Matrix3D;		public class AccelerometerHandler {				private static const RAD_TO_DEG:Number = 180/Math.PI;		private var _forceSmoothing:Number;		// amount to smooth incoming data by		private var _orientationSmoothing:Number;	// amount to smooth orientation by				private var _accelReal:Vector3D;		// current acceleration		private var _accelForce:Vector3D;		// smoothed for force		private var _accelOrientation:Vector3D;	// smoothed for acceleration		private var _orientation:Vector3D;		// current orientation		private var _transform:Matrix3D;				private var _orientDirty:Boolean;		private var _transformDirty:Boolean;		// contains orientation matrix		public function AccelerometerHandler() {			_forceSmoothing = 0.1;			// little bit of smoothing for force			_orientationSmoothing = 0.9;	// lots of smoothing for orientation / matrix						_accelForce = new Vector3D();			_accelReal = new Vector3D();			_accelOrientation = new Vector3D();			_orientation = new Vector3D();			_transform = new Matrix3D();		}				/** returns current smoothed accelerometer data (value in number of g's (1g = gravity, 9.8m/s^2)		 */		public function get force():Vector3D {			return _accelForce;		}				/** returns current real accelerometer data (value in number of g's (1g = gravity, 9.8m/s^2)		 */		public function get rawAcceleration():Vector3D {			return _accelReal;		}				/** returns current orientation in degrees (x: pitch, y: roll, z: not used)		 */		public function get orientation():Vector3D {			updateOrientation();			return _orientation;		}				public function get transform():Matrix3D {			updateMatrix();			return _transform;		}				/** set amount of smoothing on data (0: no smooth, 1: very smooth)		 */		public function set forceSmoothing(value:Number):void {			_forceSmoothing = value;		}				public function set orientationSmoothing(value:Number):void {			_orientationSmoothing = value;		}		// platform specific accelerometer engine should call this when motion is detected		public function update(x:Number, y:Number, z:Number):void {						_orientDirty = _transformDirty = true;						_accelReal.x = x;			_accelReal.y = y;			_accelReal.z = z;						var lerpFactor:Number = 0.0;						if( _forceSmoothing ) {				lerpFactor = 1.0 - _forceSmoothing;				if( lerpFactor > 1.0 ) lerpFactor = 1.0;				else if( lerpFactor < 0.01 ) lerpFactor = 0.01;								var tempForce:Vector3D;				tempForce = _accelReal.subtract(_accelForce);				tempForce.scaleBy(lerpFactor);				_accelForce = _accelForce.add(tempForce);			} else {				_accelForce.x = x;				_accelForce.y = y;				_accelForce.z = z;			}						if( _orientationSmoothing ) {				lerpFactor = 1.0 - _orientationSmoothing;				if( lerpFactor > 1.0 ) lerpFactor = 1.0;				else if( lerpFactor < 0.01 ) lerpFactor = 0.01;								var tempOrientation:Vector3D;				tempOrientation = _accelReal.subtract(_accelOrientation);				tempOrientation.scaleBy(lerpFactor);				_accelOrientation = _accelOrientation.add(tempOrientation);			} else {				_accelOrientation.x = x;				_accelOrientation.y = y;				_accelOrientation.z = z;			}		}		private function updateOrientation():void {			if( !_orientDirty ) return;			_orientDirty = false;						_orientation.x = Math.atan2(_accelOrientation.y, -_accelOrientation.z) * RAD_TO_DEG;			_orientation.y = Math.atan2(_accelOrientation.x, -_accelOrientation.z) * RAD_TO_DEG;			_orientation.z = 0;		}				private function updateMatrix():void {			if( !_transformDirty) return;			_transformDirty = false;						var length:Number;						// make sure we have a big enough acceleration vector			length = Math.sqrt(_accelOrientation.x * _accelOrientation.x + _accelOrientation.y * _accelOrientation.y + _accelOrientation.z * _accelOrientation.z);			if( length < 0.1 ) return;						//0  1  2  3			//4  5  6  7			//8  9  10 11			//12 13 14 15						var v:Vector.<Number> = new Vector.<Number>(16, true);			// clear matrix to be used to rotate from the current referential to one based on the gravity vector			_transform.identity();			v[15] = 1.0;						// setup first matrix column as gravity vector			v[0] = _accelOrientation.x / length;			v[1] = _accelOrientation.y / length;			v[2] = _accelOrientation.z / length;						// setup second matrix column as an arbitrary vector in the plane perpendicular to the			// gravity vector {Gx, Gy, Gz} defined by the equation "Gx * x + Gy * y + Gz * z = 0" 			// in which we arbitrarily set x=0 and y=1						v[4] = 0.0;			v[5] = 1.0;			v[6] = -_accelOrientation.y / _accelOrientation.z;			length = Math.sqrt(v[4] * v[4] + v[5] * v[5] + v[6] * v[6]);			v[4] /= length;			v[5] /= length;			v[6] /= length;						// setup third matrix column as the cross product of the first two				v[8] = v[1] * v[6] - v[2] * v[5];			v[9] = v[4] * v[2] - v[6] * v[0];			v[10] = v[0] * v[5] - v[1] * v[4];				_transform.rawData = v;					}	}	}